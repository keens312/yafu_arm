@* Generating 32bit-primes.

Copyright (C) 2000 Jens Franke.
This file is part of mpqs4linux, distributed under the terms of the 
GNU General Public Licence and WITHOUT ANY WARRANTY.

You should have received a copy of the GNU General Public License along
with this program; see the file COPYING.  If not, write to the Free
Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.

The primes below this bound are stored by their differences, which are
generated by an Eratosthenes sieve when the program starts.
Since this sieving procedure is much quicker than the factorisation
methods we use, it makes sense to execute it on startup rather than to waste
hard disk space on storing its results.

@(primgen32.c@>=
#include <string.h>
#include <math.h>
#include <sys/types.h>
#include <limits.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <gmp.h>

#include "asm/siever-config.h"
#include "primgen32.h"
#include "if.h"

#ifdef DEBUG
#define NPrimes16Bit 6542
#endif

#define P32_SIEVESIZE 0x200000
#define PRIMEDIFFS_ALLOCSIZE P32_SIEVESIZE/4 /* must be > 65536 */
#define PD_COM_ALLOC PRIMEDIFFS_ALLOCSIZE /* Maybe add something to
                                             change this behaviour. */

static unsigned char *primediffs=NULL;
static u32_t NCommonPrimes;

@ To generate very large 32 bit primes, it becomes unpractical to
store the differences in a common array. It is better to keep them
in a structure which is stored by the caller of these function.
All necessary initializations are carried out by |firstprime|,
the deallocation is done by |clearprime|.
We allow for the possibility to tell these routine not to return
any prime which is not in the publich array.

@(primgen32.h@>=
typedef struct {
  u32_t Pind;
  u32_t first_in_sieve;
  u32_t nPrim;
  u32_t Prime;
  unsigned char *PDiffs;
  u32_t use_private;
  u32_t PDiffs_allocated;
} pr32_struct;

void initprime32(pr32_struct *ps);
u32_t firstprime32(pr32_struct *ps);
u32_t nextprime32(pr32_struct *ps);
void clearprime32(pr32_struct *ps);
u32_t pr32_seek(pr32_struct *ps,u32_t lb);

@
@(primgen32.c@>=
void initprime32(pr32_struct *ps)
{
  if(primediffs==NULL)
    @<Sieve 16-bit primes@>@;
  ps->Pind=0;
  ps->PDiffs=NULL;
  ps->nPrim=0;
  ps->Prime=0;
  ps->PDiffs_allocated=0;
  ps->first_in_sieve=0;
  ps->use_private=1;
}

@
@(primgen32.c@>=
void clearprime32(pr32_struct *ps)
{
  if(ps->PDiffs) free(ps->PDiffs);
  ps->PDiffs_allocated=0;
}

@
@(primgen32.c@>=
u32_t firstprime32(pr32_struct *ps)
{
  ps->first_in_sieve=0;
  ps->Prime=2;
  ps->Pind=0;
  return 2;
}

@
@(primgen32.c@>=
u32_t nextprime32(pr32_struct *ps)
{
nextprim_start:
  if(ps->first_in_sieve) {
    if(ps->Pind<ps->nPrim) {
      ps->Prime+=2*ps->PDiffs[ps->Pind++];
      return ps->Prime;
    } else {
      if(ps->first_in_sieve<U32_MAX-2*P32_SIEVESIZE) {
        ps->first_in_sieve+=2*P32_SIEVESIZE;
        @<Sieve more primes@>@;
      } else return 0; /* Exhausted all 32-bit primes. */
    }
  }
  if(++(ps->Pind)==1) {
    ps->Prime=3;
    return 3;
  }
  if(ps->Pind < PD_COM_ALLOC) {
    if(ps->Pind>=NCommonPrimes) @<Sieve more common primes@>@;
    ps->Prime+=2*primediffs[ps->Pind];
    return ps->Prime;
  } else {
    if(ps->use_private==0) return 0; /* Exhausted public primes. */
    ps->first_in_sieve=ps->Prime+2;
    ps->Pind=0;
    ps->nPrim=0;
    @<Sieve more primes@>@;
  }
}

@ First sieve in |primediffs|, then use it to store the differences.
Only sieve odd numbers.
@<Sieve 16...@>=
{
  u32_t i,j,p;
  primediffs=xmalloc(PRIMEDIFFS_ALLOCSIZE);
  memset(primediffs,1,1+USHRT_MAX);
  for(i=3;i<0x100;i+=2) {
    if(primediffs[i])
      for(j=i*i;j<=USHRT_MAX;j+=i*2) primediffs[j]=0;
  }
  p=3;
  for(i=2,j=5;j<=USHRT_MAX;j+=2)
    if(primediffs[j]) {
      primediffs[i++]=(j-p)/2;
      p=j;
    }
  NCommonPrimes=i;
#if 0
  if(NCommonPrimes  != NPrimes16Bit) Schlendrian("%u!!!\n",NPrimes16Bit);
#endif
}

@ Only sieve odd numbers.
@<Sieve more c...@>=
{
  unsigned char *sieve;
  u32_t i,M,q,j,diff,dmax=0,oldprime,start;

  sieve=xmalloc(P32_SIEVESIZE);
  memset(sieve,1,P32_SIEVESIZE);
  /* Obviously, we are in a situation where |Prime| holds the largest
     prime we have obtained so far. */
  oldprime=ps->Prime;
  start=oldprime+2;
  M=1+floor(sqrt(start+2*P32_SIEVESIZE));
  for(i=2,q=3;q<=M;q+=2*primediffs[i++]) {
    j=start%q;
    if(j) {
      if(j&1) j=(q-j)/2;@+ else j=q-j/2;
    }
    for(;j<P32_SIEVESIZE;j+=q) sieve[j]=0;
  }
  for(i=0,j=0,q=start;i<P32_SIEVESIZE;i++,q+=2) if(sieve[i]) {
    if(!j) {
#if 0
      logbook(4,"%u in sieve No\n",q);
#endif
      j=1;
    }
    diff=(q-oldprime)/2;
    if(diff>dmax && (dmax=diff)>UCHAR_MAX)
      complain("Difference %u between consecutive primes!\n",dmax);
    if(NCommonPrimes < PD_COM_ALLOC) {
      primediffs[NCommonPrimes++]=diff;
      oldprime=q;
    } else break;
  }
  free(sieve);
#if 0
  logbook(4,"Largest diff in Sieve was %u\n",dmax);
#endif
}

@
@<Sieve more p...@>=
{
  unsigned char *sieve;
  u32_t i,M,j,diff,q,dmax=0,lasti,nprim,ssz;

  sieve=xmalloc(P32_SIEVESIZE);
  if(ps->PDiffs_allocated==0) {
    ps->PDiffs=xmalloc(PD_COM_ALLOC);
    ps->PDiffs_allocated=PD_COM_ALLOC;
  }
  memset(sieve,1,P32_SIEVESIZE);
  /* Obviously, we are in a situation where |Prime| holds the largest
     prime we have obtained so far. */
  if(ps->first_in_sieve<U32_MAX-2*P32_SIEVESIZE) ssz=P32_SIEVESIZE;
  else ssz=(U32_MAX-ps->first_in_sieve)/2;
  M=1+floor(sqrt(ps->first_in_sieve+2*ssz));
  for(i=2,q=3;q<=M;q+=2*primediffs[i++]) {
    j=ps->first_in_sieve%q;
    if(j) {
      if(j&1) j=(q-j)/2;@+ else j=q-j/2;
    }
    for(;j<ssz;j+=q) sieve[j]=0;
  }
  for(i=0,nprim=0;i<ssz;i++) if(sieve[i]) {
#if 0
    if(!j) {
      logbook(4,"%u in sieve No\n",q);
      j=1;
    }
#endif
    if(!nprim) {
      nprim=1;
      ps->Prime=ps->first_in_sieve+2*i;
      lasti=i;
    } else {
      if(nprim>ps->PDiffs_allocated)
        complain("Should never find that many primes!\n");
      diff=i-lasti;
      lasti=i;
      if(diff>dmax && (dmax=diff)>UCHAR_MAX)
        complain("Difference %u between consecutive primes!\n",dmax);
      ps->PDiffs[nprim-1]=diff;
      nprim++;
    }
  }
  free(sieve);
  if(nprim==0)
    complain("Found no prime\n");
  ps->nPrim=nprim-1;
  ps->Pind=0;
  return ps->Prime;

#if 0
  logbook(4,"Largest diff in Sieve was %u\n",dmax);
#endif
}

@
@(primgen32.c@>=
u32_t
pr32_seek(pr32_struct *ps,u32_t lb)
{
  if(lb<3) return firstprime32(ps);
  if(lb%2==0) lb++;
  ps->first_in_sieve=lb;
  @<Sieve more primes@>@;
}
